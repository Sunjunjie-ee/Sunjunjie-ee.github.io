<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见排序类算法合集</title>
      <link href="/2021/07/04/chang-jian-pai-xu-lei-suan-fa-he-ji/"/>
      <url>/2021/07/04/chang-jian-pai-xu-lei-suan-fa-he-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="常见排序类算法合集（java实现）"><a href="#常见排序类算法合集（java实现）" class="headerlink" title="常见排序类算法合集（java实现）"></a>常见排序类算法合集（java实现）</h1><p>排序类算法是我们平时做题时常被使用，本文将从简至难介绍各种主流排序类算法的优劣势与流程。<del>Arrays.sort()他不香吗</del></p><h2 id="1-冒泡排序（Bubble-sort）"><a href="#1-冒泡排序（Bubble-sort）" class="headerlink" title="1. 冒泡排序（Bubble sort）"></a>1. 冒泡排序（Bubble sort）</h2><ol><li><p>冒泡排序是排序算法中最初级的算法之一，简单易懂，其基本思想就是比较两个相邻的数字大小，如果逆序则交换。</p></li><li><p>算法描述：</p><ul><li>比较相邻的两个元素，按照升序的顺序排列；</li><li>每一趟都对相邻的元素做同样的操作，换言之，第k趟交换中会确定一个第k大的元素；</li><li>假设数组长度为n，只需要进行n-1趟的排序即可，因为经历过n-1趟的排序后已经确定了n-1个元素的位置，最后一个元素的位置也自然而然的被确定了。</li></ul></li><li><p>下面给出图示：由于其较大的数下沉，较小的数上浮所以被人形象的称之为冒泡。</p><p><img src="/images/sortCollection/1.gif" alt="冒泡排序图解"></p></li><li><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//进行空值判断</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token comment">//第一次遍历是对趟数的遍历,只需要进行n-1次</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//第二次遍历是为了比较相邻的两个元素大小，需要比较的元素个数会随着趟数的增加而减少</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//按升序方式排列</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>冒泡排序的优化</p><p>下面我们来分析冒泡排序。需要注意的是，不管初始数组中的数据如何排列，排一个长度为n的列表都要进行n-1次遍历。总的比较次数是1从n-1的所有正整数的和。比较复杂度是O(n2)。因为冒泡排序必须要在最终位置之前不断的交换数据，所以常被人认为是效率最低的一种排列方式。我们发现如果在哪趟排序中没有发生交换，就意味着此时排序已经完成可以提前结束。下方给出代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//进行空值判断</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token comment">//第一次遍历是对趟数的遍历,只需要进行n-1次</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//第二次遍历是为了比较相邻的两个元素大小，需要比较的元素个数会随着趟数的增加而减少</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//按升序方式排列</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token comment">//如果没有发生交换则直接返回</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>      <span class="token comment">//否则就将flag置为false进行下一趟的比较</span>      <span class="token keyword">else</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="2-选择排序-Selection-sort"><a href="#2-选择排序-Selection-sort" class="headerlink" title="2. 选择排序(Selection sort)"></a>2. 选择排序(Selection sort)</h2><ol><li><p>选择排序的基本思想就是一次遍历中只交换一次数据，每次遍历中找到第n小的数字将其放到正确的位置处。</p></li><li><p>动图演示：</p><p><img src="/images/sortCollection/2.gif" alt="选择排序图解"></p></li><li><p>选择排序的基本思想于冒泡排序相同，不同的是选择排序一次只排一个元素。复杂度为O(n2)。本处不多赘述直接给出代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//空值判断</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//对趟数的遍历，遍历次数为n-1</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">,</span> min <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//寻找第j小的数字， 需要注意的是索引小于i的数字已经完成了排序不需要再进行判断</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>        min <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果最小值发生了变化则进行交换</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>      arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="3-插入排序-Insertion-sort"><a href="#3-插入排序-Insertion-sort" class="headerlink" title="3. 插入排序(Insertion sort)"></a>3. 插入排序(Insertion sort)</h2><ol><li><p>插入排序的基本思想是在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p></li><li><p>算法描述：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li><li><p>动图演示： </p><p> <img src="/images/sortCollection/3.gif" alt="插入排序图解"></p></li><li><p>插入排序与上述两种排序方式的区别也不大，复杂度为O(n2)，本处直接给出代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//空值判断</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//对趟数的遍历，由于i等于0时没有交换的对象所以从i=1开始遍历。相似地，趟数为n-1。</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//insertVal记录当前的值，insertIndex记录当前值的前一个已经排好序的值</span>    <span class="token keyword">int</span> insertVal <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> insertIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//如果当前值小于上一个已经排好序的值，就循环下述代码</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>insertIndex <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> insertVal <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//将上一个已经排好序的值后移一位</span>      array<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//索引前移</span>      insertIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//将当前值放到正确的位置</span>    array<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> insertVal<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="4-希尔排序-Shell-sort"><a href="#4-希尔排序-Shell-sort" class="headerlink" title="4. 希尔排序(Shell sort)"></a>4. 希尔排序(Shell sort)</h2><ol><li><p>希尔排序又叫“缩小间隔排序”是基于插入排序的一种排序算法，改进了插入排序，将原数组先分组再进行插入排序。希尔排序减少了很多无效的对比，成功将时间复杂度降低到了O(n2)以下。</p></li><li><p>算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul></li><li><p>动图演示：</p><p> <img src="/images/sortCollection/4.gif" alt="shell排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                   preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>               <span class="token punctuation">}</span>               array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> array<span class="token punctuation">;</span>   <span class="token punctuation">}</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="5-归并排序-Merge-sort"><a href="#5-归并排序-Merge-sort" class="headerlink" title="5. 归并排序(Merge sort)"></a>5. 归并排序(Merge sort)</h2><ol><li><p>我们现在把注意力转移到用分而治之策略来改进排序算法的表现。第一个就是归并排序。归并是一种递归算法，它持续地将一个数组分为两半。如果数组是空的或者只有一个元素，就定义递归结束，意味着排序好了。如果数组还有元素，就将数组拆分然后分别对两个部分调用递归进行排序。归并：把两个排序好的数组结合到一起合成一个单一的有序地新数组。</p></li><li><p>算法描述</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul></li><li><p>动图演示：</p><p><img src="/images/sortCollection/5.gif" alt="归并排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//递归的过程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//递归终止条件</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//取中值，分而治之</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//左半数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//右半数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用自身</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//归并的过程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//新建res数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化左半右半数组的索引</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//往res数组中添加数据</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">?</span> right<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> left<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>归并排序的分析：为了分析归并算法，我们需要考虑它实施的两个不同步骤。第一步，数组被拆分，这一部分的时间复杂度是O(logn)。而第二步则是合并，每个数组中的元素最终将被放置在排序好的数组中，所以合并操作一个长度为n的数组需要n的数量级的操作。因此归并排序的时间复杂度为O(nlogn)。于此同时，拆分列表需要很大一部分的空间来储存这些被拆分的列表。可能使得归并排序被运用在大数据集合时出现错误。</p></li></ol><h2 id="6-快速排序-Quick-sort"><a href="#6-快速排序-Quick-sort" class="headerlink" title="6. 快速排序(Quick sort)"></a>6. 快速排序(Quick sort)</h2><p>他来了他来了，快排他带着offer走来了。对于校招而言，快速排序的重要性就不用我多说了吧。要求熟记，理解，可以快速手写。同时，快排中的partition思想在很多算法题中也可以灵活运用，这里就不多展开了，感兴趣的小伙伴可以去我的<a href="https://sunjunjie-ee.github.io/2021/07/02/leetcode/">leetcode刷题合集</a>里看。</p><ol><li><p>快速排序的基本思想：每一轮的排序都会将区域分割成两个独立的分区，其中左分区的序列的所有值均会比右分区的所有值小。然后对子分区进行同样的分割操作，最后达到整体有序。在排序的过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较的次数，降低了排序时间。</p></li><li><p>算法描述：快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>动图演示：</p><p><img src="/images/sortCollection/6.gif" alt="快速排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//取最左元素为分裂点</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> left<span class="token punctuation">,</span> r <span class="token operator">=</span> right<span class="token punctuation">,</span> pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里注意必须要先从右边开始查找。</span>  <span class="token comment">/*  两个while执行完， l和r同时指向一个 &lt; array[l] 的数，因此最后再执行交换才可以把基准值交换到正确的位置。而如果互换这两句，那么就是l先向右遍历，两个while执行完，l和r同时指向一个 &gt; array[l] 的数，那么就不对了。如果要交换写，那么同时也要把基准值换成数组的末元素，让整个基准值划分操作对称。  */</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">!=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//将大于分裂点的元素标记</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token operator">&amp;&amp;</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">//将小于分裂点的元素标记</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//进行交换实现排序</span><span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>      array<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>      array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">//最终将基准数归位</span>  array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>  <span class="token comment">//递归处理左半数组</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//递归处理右半数组</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>快速排序的分析： 假如一个长度为n的数组，如果每次分裂都发生在数组的中央，那么将会进行logn次分裂。综合的时间复杂度为O(nlogn)。不幸的是，分裂点(pivot)的选取只能凭借运气，最差的情况下可能导致一侧一直都没有数据这时的时间复杂度为O(n2)+递归，可能还不如冒泡排序。pivot的选取一般取最左，最右，或者是中间。</p></li></ol><h1 id="未完待续。。。。"><a href="#未完待续。。。。" class="headerlink" title="未完待续。。。。"></a>未完待续。。。。</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> sort </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校招刷题指南</title>
      <link href="/2021/07/02/leetcode/"/>
      <url>/2021/07/02/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招算法合集（包含剑指offer和leetcode）-持续更新ing"><a href="#秋招算法合集（包含剑指offer和leetcode）-持续更新ing" class="headerlink" title="秋招算法合集（包含剑指offer和leetcode）      持续更新ing"></a>秋招算法合集（包含剑指offer和leetcode）      持续更新ing</h1><p>本博客主要目的是记录自己刷题轨迹，整理题型理清思路，利用写博客一方式温故而知新，写者小白一只菜鸡一枚如有写错的地方还望大佬们海涵指点迷津。</p><h2 id="1-LinkedList"><a href="#1-LinkedList" class="headerlink" title="1.LinkedList"></a>1.LinkedList</h2><h3 id="1-1-环形链表"><a href="#1-1-环形链表" class="headerlink" title="1.1 环形链表"></a>1.1 环形链表</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode141-环形链表</a></p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode142-环形链表2</a></p><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">leetcode287-寻找重复数</a></p><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指offer52-两个链表的第一个公共节点</a></p><p>第141题考察点是判断环形链表，第142道题是判断环形的入口点。<br>这三道题都涉及到了环形链表知识点，针对这类问题只需要熟记两次双指针即可，第一次为快慢指针，快指针的步长是慢指针的二倍，当快慢指针第一次相遇时停止。第二次的双指针步数相同。下方列出判断环形的入口的核心代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//第一次快慢指针</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> slow <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fast <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//第二次普通双指针</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> fast<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>剑指offer52</strong>寻找两个链表的第一个公共节点问题可以转换成环问题的变种，取双指针分别在两个链表上遍历，当一个链表遍历完成后前往下一个链表，如果两个链表有公共节点的话，就一定会有相等的时候，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token class-name">ListNode</span> nodeA <span class="token operator">=</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> nodeB <span class="token operator">=</span> headB<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>nodeA <span class="token operator">!=</span> nodeB<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//如果nodeA不为空就继续前往下一个节点，如果为空就前往B链表的头部节点</span>    nodeA <span class="token operator">=</span> nodeA <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> nodeA<span class="token punctuation">.</span>next <span class="token operator">:</span> nodeB<span class="token punctuation">;</span>    nodeB <span class="token operator">=</span> nodeB <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> nodeB<span class="token punctuation">.</span>next <span class="token operator">:</span> nodeA<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> nodeA<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：并不用担心没有公共节点的时候会进入死循环的问题，因为从某种意义上来说，null也是公共节点。当nodeA和nodeB同时为null时循环就会结束了并返回null值。</p><h3 id="1-2-倒转链表"><a href="#1-2-倒转链表" class="headerlink" title="1.2 倒转链表"></a>1.2 倒转链表</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指offer06-从尾到头打印链表</a><br><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指offer24-反转链表</a><br>反转类型的题都可以考虑用栈做，利用栈先进后出的特性。下方给出<strong>剑指offer06</strong>利用栈的示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对于<strong>剑指offer24题</strong>依旧可以利用栈来解答，读者可以自行尝试，本处使用另外一种方法头插法（迭代）增加运行速度，下方给出示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> head<span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    curr<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>    pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>    curr <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> pre<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到利用迭代只需要循环一次，比起求助于栈速度要快。另外，此处切记不可以求方便省略next节点写成下列形式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//此时已经改变了curr节点！</span>curr<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同理于数组元素的交换，熟能生巧举一反三。<br>同样的问题在二叉树中问题也同样存在本处给出链接<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指offer27-二叉树的镜像</a>，读者可以先行挑战。</p><h3 id="1-3-倒数第n个节点"><a href="#1-3-倒数第n个节点" class="headerlink" title="1.3 倒数第n个节点"></a>1.3 倒数第n个节点</h3><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指offer22-链表中倒数第k个节点</a><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指offer18-删除链表的节点</a><br>链表中涉及到倒数or删除等字样时，快慢指针往往是一个好办法，利用两个指针分别记录需要的位置进行next连接即可。总而言之，这类问题普遍都不难，想到双指针问题就已经解决了大半。本处给出<strong>剑指offer22题</strong>的示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">ListNode</span> latter <span class="token operator">=</span> head<span class="token punctuation">,</span> former <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>latter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    latter <span class="token operator">=</span> latter<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>latter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    former <span class="token operator">=</span> former<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    latter <span class="token operator">=</span> latter<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> former<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-其他"><a href="#1-其他" class="headerlink" title="1.? 其他"></a>1.? 其他</h3><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指offer25-合并两个排序的链表</a><br><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指offer35-复杂链表的复制</a><br><strong>剑指offer25</strong>题并不难只要遍历逐个比较就可以得出结果，有一个需要注意的地方就是头节点的建立，下方给出错误示范和正确样例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//错误,此处l1或者l2其中有空列表的话会报空指针异常，进行特例分析也显得麻烦，不能直接返回null。</span><span class="token class-name">ListNode</span> head <span class="token operator">=</span> L1<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> l2<span class="token punctuation">.</span>val<span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">;</span><span class="token class-name">ListNode</span> res <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//正确,给头节点附一个值并在返回时将其省略，既优雅又避免了空值的干扰。</span><span class="token class-name">ListNode</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>剑指offer35题</strong>的关键思想是哈希表，利用<code>map.put(curr, new Node(curr.val)</code>，可以巧妙的将节点的属性储存下来，进行深拷贝的时候查询key值也十分便利。再遍历构建新链表各节点的<code>next</code>和<code>random</code>引用指向即可。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><p>在介绍二叉树的问题之前，让我们先来了解下树的几种遍历方式，只要掌握了这几种遍历方式，树的题目都可以迎刃而解。建议读者仔细阅读自己实现一次加深理解。</p><h3 id="2-1基础知识"><a href="#2-1基础知识" class="headerlink" title="2.1基础知识"></a>2.1基础知识</h3><h4 id="2-1-1树的递归遍历"><a href="#2-1-1树的递归遍历" class="headerlink" title="2.1.1树的递归遍历"></a>2.1.1树的递归遍历</h4><p>二叉树的问题都离不开递归思想，常见的递归遍历所有节点的方法分为三种：</p><ul><li><p>前序遍历：根-&gt;左-&gt;右</p></li><li><p>中序遍历：左-&gt;根-&gt;右</p></li><li><p>后序遍历：左-&gt;右-&gt;根</p></li></ul><p>下列给出递归实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//前序</span><span class="token keyword">void</span> <span class="token function">preOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrederRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//中序</span><span class="token keyword">void</span> <span class="token function">inOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">postOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">postOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2树的非递归遍历"><a href="#2-1-2树的非递归遍历" class="headerlink" title="2.1.2树的非递归遍历"></a>2.1.2树的非递归遍历</h4><p>本处开始讨论树的遍历非递归实现。</p><p>1). 以前序遍历为例，先以根左右的顺序访问根节点，对于任意节点node，先访问其本身，之后判断左子树是否为空，如果不为空则重复上述步骤直到为空为止。当左子树为空时则开始访问右子树，由于访问左子节点之后需要反过来访问其右子节点所以此处借用栈的支持。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//前序遍历的非递归实现</span><span class="token keyword">void</span> <span class="token function">preOrderStack</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TreeNode</span> curr <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2).  层次遍历，层次遍历不同于上述三种遍历方式，层次遍历以每一层的节点为单位进行遍历。层序遍历的代        码较为简单，利用队列的FIFO特性，只需要一个队列即可，现在队列中加入根节点。之后对于任意一个节点        而言，出队列时如果其左子节点于右子节点有不为空的就将其放入队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//二叉树的层次遍历</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">levelRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//先将根节点加入队列</span>  queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//将当前队列头部节点取出</span>    <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果左子节点不为空就将左子节点放入到队列中</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果右子节点不为空就将右子节点放入到队列中</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2树的深度遍历"><a href="#2-2树的深度遍历" class="headerlink" title="2.2树的深度遍历"></a>2.2树的深度遍历</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指offer07-重建二叉树</a>                                     <a href="#jump1">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指offer26-树的子结构</a>                                     <a href="#jump2">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指offer27-二叉树的镜像</a>                                 <a href="#jump3">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指offer28-对称的二叉树</a>                                 <a href="#jump4">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指offer33-二叉搜索树的后序遍历递归</a>          <a href="#jump5">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer34-二叉树中和为某一值的路径</a>          <a href="#jump9">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指offer36-二叉搜索树与双向链表</a>                  <a href="#jump6">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指offer54-二叉树搜索树的第k大节点</a>            <a href="#jump10">跳转至题解</a>  </p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指offer55-I-二叉树的深度</a>                               <a href="#jump7">跳转至题解</a></p><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指offer55-II-平衡二叉树</a>                                  <a href="#jump8">跳转至题解</a></p><p><span id="jump1">剑指offer07</span></p><p><strong>剑指offer07题</strong>明面上考察的是二叉树的重建，实质上其实还是树的深度遍历问题。只要有中序遍历以及前序遍历，后序遍历中的一个，就可以实现二叉树的重建。需要注意的是中序遍历是必须的，我们需要从中序遍历中得知根节点左右子树的位置，再从前序遍历或后序遍历中获取根节点的位置。本题给出的是前序遍历与中序遍历，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preOrder<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>preorder <span class="token operator">=</span> preorder<span class="token punctuation">;</span>  <span class="token comment">//将中序遍历的元素放入哈希表中</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//三个参数分别为根节点索引（根据前序获得），左子树起始位置与右子树结束位置（根据中序遍历获得）</span>  <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> preRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> inLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> inRight<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>inLeft <span class="token operator">&gt;</span> inRight<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//根据根节点索引在前序遍历中查找根节点</span>  <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span>preRoot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在哈希表中查询前序遍历中得到的根节点确定根节点在中序遍历中的位置。</span>  <span class="token keyword">int</span> idx <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">[</span>preRoot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取根节点的左子节点。三个参数分别为左子树根节点前序遍历索引，左子树开始位置，左子树的截止位置（idx - 1）中序遍历的根节点索引之前的索引就是左子树节点。</span>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>preRoot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inLeft<span class="token punctuation">,</span> idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取根节点右子节点。三个参数分别为右子树根节点前序遍历索引（根节点位置+左子树长度即为右子树的根节点索引），右子树的起始索引，右子树的截止索引。</span>  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>preRoot <span class="token operator">+</span> <span class="token punctuation">(</span>idx <span class="token operator">-</span> inLeft<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump2">剑指offer26</span></p><p><strong>剑指offer26题</strong>主要考察的就是树的深度遍历，当判断一个树是否为另一个树的子结构时需要满足三个条件</p><ol><li><p>根节点是否相同；</p></li><li><p>左子节点是否相同；</p></li><li><p>右子节点是否相同；</p></li></ol><p>只要清楚知道上述的三个条件和树的深度遍历思想，这道题就迎刃而解了，先寻找相同的根节点然后再判断左右子节点即可。相同的根节点有可能会在三个位置出现：</p><ol><li>A的根节点处；</li><li>A的左子树中；</li><li>A的右子树中；</li></ol><p>下方给出示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//空值判断</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">B</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//判断上述的三个条件，必须同时满足才可以将B称为A的子树</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token class-name">B</span><span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//寻找相同的根节点，相同的根节点要么在左子树中存在要么在右子树中存在(即使同时存在也不影响），所以此处用||</span>  <span class="token keyword">return</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//对所有节点进行逐个判断</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//B值为null意味着B树中的所有节点都通过了校验</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">B</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//A值为null意味着A树中所有的节点都不符合要求</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//相同时继续分别判断二叉树A，B的左右节点</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token class-name">B</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump3">剑指offer27</span></p><p><strong>剑指offer27</strong>二叉树的镜像问题也是二叉树的遍历问题，只要互换根节点的左右节点即可，下方给出部分示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeNode</span> temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里不能为了省事写成mirrorTree(root.left)，因为在上一行代码中已经改变了树结构。</span>root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump4">剑指offer28</span></p><p><strong>剑指offer28</strong>对称二叉树的性质是根节点的左节点等于其右节点，知道这一点后问题就迎刃而解了。从树的根节点开始递归调用，判断其左子节点是否等于右子节点即可。剑指offer27题与剑指offer28题有异曲同工之处，建议一起理解。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//当左右子节点都为空时意味着完成了所有节点的校验</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//当有一侧节点先行为空时或左子节点值不等于右子节点值时，即为不对称</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> left <span class="token operator">!=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump5">剑指offer33</span></p><p><strong>剑指offer33</strong>中有一个很重要的条件那就是二叉搜索树，所谓二叉搜索树就是根节点以左的节点值都小于根节点，根节点以右的节点值都大于根节点。利用后序遍历左-&gt;右-&gt;根的顺序即可快速定位到根节点，在利用二叉搜索树的性质进行比较即可。示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//当l大于r的时候，证明校验已经完成</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> p <span class="token operator">=</span> l<span class="token punctuation">;</span>  <span class="token comment">//r节点是后序遍历的中的最后一个索引，即为根节点，当前节点大小值小于根节点时移动指针</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;</span> postorder<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//mid值即为第一个大于根节点的节点值，同时意味着从mid节点开始，进入到了根节点的右子树中</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span> p<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&gt;</span> postorder<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//指针移动结束时，索引值等于根节点索引证明所有节点符合二叉搜索树性质，继续判断当前节点的左子树与右子树是否符合</span>  <span class="token keyword">return</span> p<span class="token operator">==</span>r <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump9">剑指offer34</span></p><p><strong>剑指offer34题</strong>考察的是对于树的递归思想和dfs思想的结合，关于dfs笔者正在整理相关题目，在这里不多赘述直接给出代码，相信有深度优先遍历题目经验的小伙伴经历过了上面这么多道二叉树相关题目的洗礼，这题应该是闭着眼睛都能写出来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> path<span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">pathSum</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//递归的终止条件</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">//将当前节点的值放入到path列表中</span>  path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  target <span class="token operator">-=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>  <span class="token comment">//target等于0时意味着path中所有元素的和等于target值，并且在当前节点的左右子树都为空时（路径已经到末尾，确保最后一个节点是叶子节点），才可以将当前path列表加入到res列表中</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//后序遍历</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//回溯</span>  path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump6">剑指offer36</span></p><p><strong>剑指offer-36</strong>考察的是将一个二叉搜索树转换成一个排序的循环双向链表，在这里介绍三个概念：</p><ul><li>排序链表：节点按小到大的方式排列</li><li>循环链表：链表的末尾节点与头节点相连</li><li>双向链表：当前节点指向下一个节点的同时，下一个节点也指向当前节点</li></ul><p>本题从排序链表和二叉搜索树作为切入点进行解题，如同上一道题介绍的二叉搜索树的性质，我们只需要前序递归二叉树获取最小的左子节点再按照顺序双向连接节点即可，下方给出示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Node</span> head<span class="token punctuation">,</span> prev<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//设置头节点的左指针指向链表的最后一个节点</span>  head<span class="token punctuation">.</span>left <span class="token operator">=</span> prev<span class="token punctuation">;</span>  <span class="token comment">//链表的最后一个节点指向头节点</span>  prev<span class="token punctuation">.</span>right <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> curr<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//递归的终止条件</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">//如果prev是null，证明当前节点是头节点，如果不为空则另上一个节点的右指针指向当前节点</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> prev<span class="token punctuation">.</span>right <span class="token operator">=</span> curr<span class="token punctuation">;</span>  <span class="token comment">//将头节点的值付给当前节点</span>  <span class="token keyword">else</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">//给当前节点赋左指针</span>  curr<span class="token punctuation">.</span>left <span class="token operator">=</span> prev<span class="token punctuation">;</span>  prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>  <span class="token function">recur</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump10">剑指offer54</span></p><p><strong>剑指offer54</strong>二叉搜索树的大小分布为右子树大于根节点大于左子树，是一个倒序的中序遍历，本题只要思考倒序的中序遍历怎么写即可，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> res<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>  <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump7">剑指offer55-I</span></p><p><strong>剑指offer55-I</strong>二叉树的深度问题无非就是深度遍历问题，不多赘述直接给出code：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><span id="jump8">剑指offer55-II</span></p><p><strong>剑指offer55-II</strong>主要考察平衡二叉树的问题，关于平衡二叉树的性质，给出定义，如果某二叉树中的任意节点的左右子树的深度相差不超过1，即可将其称之为平衡二叉树。结合剑指offer55-I一起看，这道题无非就是一道求深度的变种题目。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//（左子树的深度 - 右子树的深度）的绝对值小于2证明当前树为平衡二叉树，继续判断左子树与右子树</span>  <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3二叉树的层次遍历"><a href="#2-3二叉树的层次遍历" class="headerlink" title="2.3二叉树的层次遍历"></a>2.3二叉树的层次遍历</h3><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指offer32-I-从上到下打印二叉树 I</a></p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指offer32-II-从上到下打印二叉树 II</a> </p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指offer32-III-从上到下打印二叉树 III</a> </p><p><strong>剑指offer32-I</strong>考察的就是二叉树的层次遍历，多看几遍2.1中的层次遍历代码即可（不理解为啥是中等难度）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> curr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    curr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> curr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>剑指offer32-II</strong>与上一道题一样只不过是输出形式不同，这里就不给出代码了。</p><p><strong>剑指offer32-III</strong>依旧是二叉树的层次遍历问题，要求偶数层从左到右输出，奇数层从右到左输出，下方给出代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> curr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> curr<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> curr<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4查找公共父节点"><a href="#2-4查找公共父节点" class="headerlink" title="2.4查找公共父节点"></a>2.4查找公共父节点</h3><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指offer68-I-二叉搜索树的最近公共祖先</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指offer68-II-二叉树的最近公共祖先</a></p><p><strong>剑指offer68-I</strong>公共父节点可以出现的位置一共有三种情况：</p><ol><li>两个子节点都在左子树中（一个节点是另一个节点的父节点）</li><li>两个子节点都在右子树中（一个节点是另一个节点的父节点）</li><li>两个子节点分散在左右子树中</li></ol><p>利用本题中的二叉搜索树条件，可以轻松写出代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>剑指offer68-II</strong>题中失去了二叉搜索树这个条件使得判断变得麻烦了起来，但是本质上的思路还是一样的，分别判断三种情况即可，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//如果root是p或者q中的任意一个就证明p或者q是共同父节点或分散在两侧；root为null的时候证明p和q不在所查询的范围中</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token comment">//查询p，q是否在左子树中</span>  <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//查询p，q是否在右子树中</span>  <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//left和right都为null的时候证明p和q都不在树中，返回null</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//left值是在左子树中查询到的p或者q节点，当left为null的时候证明p和q都不在左子树中，直接返回right值即可（此时是情况2）</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>  <span class="token comment">//right值是右子树中查询到的p或者q节点，当right为null的时候证明q和p都不在右子树中，直接返回left值即可（此时是情况1）</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>  <span class="token comment">//如果left和right都不为空时，证明在左子树和右子树中分别找到了p和q，此时是情况3，返回当前根节点即可</span>  <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>数组可以说是我们日常写程序中最常用的数据结构了，同时也是题目量，题目种类最多的数据结构。要想把数组的题目做到得心应手一定不要死刷题，要多想多总结，形成自己的知识体系，比如看到去重相关的问题就要考虑哈希，看到排好序的数组就要开始考虑二分法一样。下面就开始数组类型的问题展示：</p><h3 id="3-1原地哈希"><a href="#3-1原地哈希" class="headerlink" title="3.1原地哈希"></a>3.1原地哈希</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指offer03-数组中重复的数字</a></p><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指offer04-二维数组中的查找</a></p><p><strong>剑指offer03</strong>考察的是在一个数组中查询重复的元素，通常来讲这类题目用哈希都可以解决，遍历数组的时间复杂度为O(n)，另外维护一个hashset的空间复杂度为O(n)。</p><p>本处想分享下原地哈希方法，因为在本题中，所有元素的值都在0～n-1之间，可以通过交换操作使元素与索引值一一对应。令索引值为其本身的值，也就是说将其放到他本应该在的位置。举个例子，现在我们有数组<code>[3,5,2,1,4,3,0]</code>，首先我们遍历数组，第一个元素为3，将其放到索引3处，也就是说交换nums[0]的位置nums[3]，现在数组变为<code>[1,5,2,3,4,3,0]</code>，我们重复上述操作直到遍历到第二个3的位置处当前数组为<code>[0,1,2,3,4,3,5]</code>，按照规则，第二个3应该放到索引3处，可是索引3处已经有了正确的值。所以就可以判断3为重复数。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//如果当前元素已经在正确的位置，就不用改动它</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果当前应该在的位置已经被另一个正确元素所占据，则判断这是一个重复元素</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//交换</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为依旧需要遍历数组，所以时间复杂度为O(n)，但是空间复杂度却降到了O(1)；</p><p><strong>剑指offer04</strong>中，给出了一个矩阵满足了每一行从左到右递增，从上到下递增的顺序排序。本题不要上来直接就开始做，先开始找规律，我们发现这个矩阵一定满足<code>matirx[i][j] &lt; matrix[i + 1][j + 1]</code>这个条件，也就是说当我们把矩阵旋转45度时，我们会惊奇的发现这是一个二叉搜索树。发现了这个规律后这道题就不难了，下方给出代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2双指针"><a href="#3-2双指针" class="headerlink" title="3.2双指针"></a>3.2双指针</h3><p>双指针式数组类型题目中最常用的办法之一，其核心思想就是维护两个指针对数组进行遍历。</p><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指offer21-调整数组顺序使奇数位于偶数前面</a></p><p><strong>剑指offer21</strong>题就是典型的双指针题目，一个指针查找奇数一个指针查找偶数然后进行交换即可。代码如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&gt;=</span> l<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;</span> r<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/02/hello-world/"/>
      <url>/2021/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
