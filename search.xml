<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见排序类算法合集</title>
      <link href="/2021/07/04/chang-jian-pai-xu-lei-suan-fa-he-ji/"/>
      <url>/2021/07/04/chang-jian-pai-xu-lei-suan-fa-he-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="常见排序类算法合集（java实现）"><a href="#常见排序类算法合集（java实现）" class="headerlink" title="常见排序类算法合集（java实现）"></a>常见排序类算法合集（java实现）</h1><p>排序类算法是我们平时做题时常被使用，本文将从简至难介绍各种主流排序类算法的优劣势与流程。<del>Arrays.sort()他不香吗</del></p><hr><h2 id="1-冒泡排序（Bubble-sort）"><a href="#1-冒泡排序（Bubble-sort）" class="headerlink" title="1. 冒泡排序（Bubble sort）"></a>1. 冒泡排序（Bubble sort）</h2><ol><li><p>冒泡排序是排序算法中最初级的算法之一，简单易懂，其基本思想就是比较两个相邻的数字大小，如果逆序则交换。</p></li><li><p>算法描述：</p><ul><li>比较相邻的两个元素，按照升序的顺序排列；</li><li>每一趟都对相邻的元素做同样的操作，换言之，第k趟交换中会确定一个第k大的元素；</li><li>假设数组长度为n，只需要进行n-1趟的排序即可，因为经历过n-1趟的排序后已经确定了n-1个元素的位置，最后一个元素的位置也自然而然的被确定了。</li></ul></li><li><p>下面给出图示：由于其较大的数下沉，较小的数上浮所以被人形象的称之为冒泡。</p><p><img src="/images/sortCollection/1.gif" alt="冒泡排序图解"></p></li><li><p>代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//进行空值判断</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token comment">//第一次遍历是对趟数的遍历,只需要进行n-1次</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//第二次遍历是为了比较相邻的两个元素大小，需要比较的元素个数会随着趟数的增加而减少</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//按升序方式排列</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>冒泡排序的优化</p><p>下面我们来分析冒泡排序。需要注意的是，不管初始数组中的数据如何排列，排一个长度为n的列表都要进行n-1次遍历。总的比较次数是1从n-1的所有正整数的和。比较复杂度是O(n2)。因为冒泡排序必须要在最终位置之前不断的交换数据，所以常被人认为是效率最低的一种排列方式。我们发现如果在哪趟排序中没有发生交换，就意味着此时排序已经完成可以提前结束。下方给出代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//进行空值判断</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token comment">//第一次遍历是对趟数的遍历,只需要进行n-1次</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//第二次遍历是为了比较相邻的两个元素大小，需要比较的元素个数会随着趟数的增加而减少</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//按升序方式排列</span><span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token comment">//如果没有发生交换则直接返回</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>      <span class="token comment">//否则就将flag置为false进行下一趟的比较</span>      <span class="token keyword">else</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h1 id="2-选择排序-Selection-sort"><a href="#2-选择排序-Selection-sort" class="headerlink" title="2.选择排序(Selection sort)"></a>2.选择排序(Selection sort)</h1><ol><li><p>选择排序的基本思想就是一次遍历中只交换一次数据，每次遍历中找到第n小的数字将其放到正确的位置处。</p></li><li><p>动图演示：</p><p><img src="/images/sortCollection/2.gif" alt="选择排序图解"></p></li><li><p>选择排序的基本思想于冒泡排序相同，不同的是选择排序一次只排一个元素。复杂度为O(n2)。本处不多赘述直接给出代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//空值判断</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//对趟数的遍历，遍历次数为n-1</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">,</span> min <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//寻找第j小的数字， 需要注意的是索引小于i的数字已经完成了排序不需要再进行判断</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>        min <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//如果最小值发生了变化则进行交换</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>      arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h1 id="3-插入排序-Insertion-sort"><a href="#3-插入排序-Insertion-sort" class="headerlink" title="3.插入排序(Insertion sort)"></a>3.插入排序(Insertion sort)</h1><ol><li><p>插入排序的基本思想是在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p></li><li><p>算法描述：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul></li><li><p>动图演示： </p><p> <img src="/images/sortCollection/3.gif" alt="插入排序图解"></p></li><li><p>插入排序与上述两种排序方式的区别也不大，复杂度为O(n2)，本处直接给出代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//空值判断</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//对趟数的遍历，由于i等于0时没有交换的对象所以从i=1开始遍历。相似地，趟数为n-1。</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//insertVal记录当前的值，insertIndex记录当前值的前一个已经排好序的值</span>    <span class="token keyword">int</span> insertVal <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> insertIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//如果当前值小于上一个已经排好序的值，就循环下述代码</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>insertIndex <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> insertVal <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//将上一个已经排好序的值后移一位</span>      array<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>insertIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//索引前移</span>      insertIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//将当前值放到正确的位置</span>    array<span class="token punctuation">[</span>insertIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> insertVal<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr></li></ol><h1 id="4-希尔排序-Shell-sort"><a href="#4-希尔排序-Shell-sort" class="headerlink" title="4. 希尔排序(Shell sort)"></a>4. 希尔排序(Shell sort)</h1><ol><li><p>希尔排序又叫“缩小间隔排序”是基于插入排序的一种排序算法，改进了插入排序，将原数组先分组再进行插入排序。希尔排序减少了很多无效的对比，成功将时间复杂度降低到了O(n2)以下。</p></li><li><p>算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul></li><li><p>动图演示：</p><p> <img src="/images/sortCollection/4.gif" alt="shell排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                   preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>               <span class="token punctuation">}</span>               array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token punctuation">}</span>           gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> array<span class="token punctuation">;</span>   <span class="token punctuation">}</span>      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="5-归并排序-Merge-sort"><a href="#5-归并排序-Merge-sort" class="headerlink" title="5. 归并排序(Merge sort)"></a>5. 归并排序(Merge sort)</h1><ol><li><p>我们现在把注意力转移到用分而治之策略来改进排序算法的表现。第一个就是归并排序。归并是一种递归算法，它持续地将一个数组分为两半。如果数组是空的或者只有一个元素，就定义递归结束，意味着排序好了。如果数组还有元素，就将数组拆分然后分别对两个部分调用递归进行排序。归并：把两个排序好的数组结合到一起合成一个单一的有序地新数组。</p></li><li><p>算法描述</p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul></li><li><p>动图演示：</p><p><img src="/images/sortCollection/5.gif" alt="归并排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//递归的过程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//递归终止条件</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token comment">//取中值，分而治之</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//左半数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//右半数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用自身</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//归并的过程</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//新建res数组</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化左半右半数组的索引</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//往res数组中添加数据</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">?</span> right<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> left<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>归并排序的分析：为了分析归并算法，我们需要考虑它实施的两个不同步骤。第一步，数组被拆分，这一部分的时间复杂度是O(logn)。而第二步则是合并，每个数组中的元素最终将被放置在排序好的数组中，所以合并操作一个长度为n的数组需要n的数量级的操作。因此归并排序的时间复杂度为O(nlogn)。于此同时，拆分列表需要很大一部分的空间来储存这些被拆分的列表。可能使得归并排序被运用在大数据集合时出现错误。</p></li></ol><hr><h1 id="6-快速排序-Quick-sort"><a href="#6-快速排序-Quick-sort" class="headerlink" title="6.快速排序(Quick sort)"></a>6.快速排序(Quick sort)</h1><p>他来了他来了，快排他带着offer走来了。对于校招而言，快速排序的重要性就不用我多说了吧。要求熟记，理解，可以快速手写。同时，快排中的partition思想在很多算法题中也可以灵活运用，这里就不多展开了，感兴趣的小伙伴可以去我的<a href="https://sunjunjie-ee.github.io/2021/07/02/leetcode/">leetcode刷题合集</a>里看。</p><ol><li><p>快速排序的基本思想：每一轮的排序都会将区域分割成两个独立的分区，其中左分区的序列的所有值均会比右分区的所有值小。然后对子分区进行同样的分割操作，最后达到整体有序。在排序的过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较的次数，降低了排序时间。</p></li><li><p>算法描述：快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>动图演示：</p><p><img src="/images/sortCollection/6.gif" alt="快速排序图解"></p></li><li><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//取最左元素为分裂点</span>  <span class="token keyword">int</span> l <span class="token operator">=</span> left<span class="token punctuation">,</span> r <span class="token operator">=</span> right<span class="token punctuation">,</span> pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里注意必须要先从右边开始查找。</span>  <span class="token comment">/*  两个while执行完， l和r同时指向一个 &lt; array[l] 的数，因此最后再执行交换才可以把基准值交换到正确的位置。而如果互换这两句，那么就是l先向右遍历，两个while执行完，l和r同时指向一个 &gt; array[l] 的数，那么就不对了。如果要交换写，那么同时也要把基准值换成数组的末元素，让整个基准值划分操作对称。  */</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">!=</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//将大于分裂点的元素标记</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivot <span class="token operator">&amp;&amp;</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token comment">//将小于分裂点的元素标记</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot <span class="token operator">&amp;&amp;</span> l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//进行交换实现排序</span><span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>      array<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>      array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">//最终将基准数归位</span>  array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>  <span class="token comment">//递归处理左半数组</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> left<span class="token punctuation">,</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//递归处理右半数组</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">&gt;</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>快速排序的分析： 假如一个长度为n的数组，如果每次分裂都发生在数组的中央，那么将会进行logn次分裂。综合的时间复杂度为O(nlogn)。不幸的是，分裂点(pivot)的选取只能凭借运气，最差的情况下可能导致一侧一直都没有数据这时的时间复杂度为O(n2)+递归，可能还不如冒泡排序。pivot的选取一般取最左，最右，或者是中间。</p></li></ol><h1 id="未完待续。。。。"><a href="#未完待续。。。。" class="headerlink" title="未完待续。。。。"></a>未完待续。。。。</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2021/07/02/leetcode/"/>
      <url>/2021/07/02/leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="秋招算法合集（包含剑指offer和leetcode）-持续更新ing"><a href="#秋招算法合集（包含剑指offer和leetcode）-持续更新ing" class="headerlink" title="秋招算法合集（包含剑指offer和leetcode）      持续更新ing"></a>秋招算法合集（包含剑指offer和leetcode）      持续更新ing</h1><p>本博客主要目的是记录自己刷题轨迹，整理题型理清思路，利用写博客一方式温故而知新，写者小白一只菜鸡一枚如有写错的地方还望大佬们海涵指点迷津。</p><h2 id="1-LinkedList"><a href="#1-LinkedList" class="headerlink" title="1.LinkedList"></a>1.LinkedList</h2><h3 id="1-1-环形链表"><a href="#1-1-环形链表" class="headerlink" title="1.1 环形链表"></a>1.1 环形链表</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode141-环形链表</a><br><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode142-环形链表2</a><br><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">leetcode287-寻找重复数</a><br>第141题考察点是判断环形链表，第142道题是判断环形的入口点。<br>这三道题都涉及到了环形链表知识点，针对这类问题只需要熟记两次双指针即可，第一次为快慢指针，快指针的步长是慢指针的二倍，当快慢指针第一次相遇时停止。第二次的双指针步数相同。下方列出判断环形的入口的核心代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//第一次快慢指针</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> slow <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>fast <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//第二次普通双指针</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">{</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> fast<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-倒转链表"><a href="#1-2-倒转链表" class="headerlink" title="1.2 倒转链表"></a>1.2 倒转链表</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指offer06-从尾到头打印链表</a><br><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指offer24-反转链表</a><br>反转类型的题都可以考虑用栈做，利用栈先进后出的特性。下方给出剑指offer06利用栈的示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对于剑指offer24题依旧可以利用栈来解答，读者可以自行尝试，本处使用另外一种方法头插法（迭代）增加运行速度，下方给出示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> curr <span class="token operator">=</span> head<span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    curr<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>    pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>    curr <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> pre<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到利用迭代只需要循环一次，比起求助于栈速度要快。另外，此处切记不可以求方便省略next节点写成下列形式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//此时已经改变了curr节点！</span>curr<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同理于数组元素的交换，熟能生巧举一反三。<br>同样的问题在二叉树中问题也同样存在本处给出链接<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指offer27-二叉树的镜像</a>，读者可以先行挑战。</p><h3 id="1-3-倒数第n个节点"><a href="#1-3-倒数第n个节点" class="headerlink" title="1.3 倒数第n个节点"></a>1.3 倒数第n个节点</h3><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指offer22-链表中倒数第k个节点</a><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指offer18-删除链表的节点</a><br>链表中涉及到倒数or删除等字样时，快慢指针往往是一个好办法，利用两个指针分别记录需要的位置进行next连接即可。总而言之，这类问题普遍都不难，想到双指针问题就已经解决了大半。本处给出剑指offer22题的示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">ListNode</span> latter <span class="token operator">=</span> head<span class="token punctuation">,</span> former <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>latter <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    latter <span class="token operator">=</span> latter<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>latter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    former <span class="token operator">=</span> former<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    latter <span class="token operator">=</span> latter<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> former<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-其他"><a href="#1-其他" class="headerlink" title="1.? 其他"></a>1.? 其他</h3><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指offer25-合并两个排序的链表</a><br><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指offer35-复杂链表的复制</a><br>剑指offer25题并不难只要遍历逐个比较就可以得出结果，有一个需要注意的地方就是头节点的建立，下方给出错误示范和正确样例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//错误,此处l1或者l2其中有空列表的话会报空指针异常，进行特例分析也显得麻烦，不能直接返回null。</span><span class="token class-name">ListNode</span> head <span class="token operator">=</span> L1<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> l2<span class="token punctuation">.</span>val<span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">;</span><span class="token class-name">ListNode</span> res <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">//正确,给头节点附一个值并在返回时将其省略，既优雅又避免了空值的干扰。</span><span class="token class-name">ListNode</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>剑指offer35题的关键思想是哈希表，利用<code>map.put(curr, new Node(curr.val)</code>，可以巧妙的将节点的属性储存下来，进行深拷贝的时候查询key值也十分便利。再遍历构建新链表各节点的<code>next</code>和<code>random</code>引用指向即可。</p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><p>二叉树的问题都离不开递归思想，常见的递归遍历所有节点的方法分为三种：</p><ul><li>前序遍历：根-&gt;左-&gt;右</li><li>中序遍历：左-&gt;根-&gt;右</li><li>后序遍历：左-&gt;右-&gt;根<br>下列给出递归实现：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//前序</span><span class="token keyword">void</span> <span class="token function">preOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrederRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//中序</span><span class="token keyword">void</span> <span class="token function">inOrderRecur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inOrderRecur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//后序改变下顺序即可本处不给出代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>本处开始讨论树的遍历非递归实现。以前序遍历为例，先以根左右的顺序访问根节点，对于任意节点node，先访问其本身，之后判断左子树是否为空，如果不为空则重复上述步骤直到为空为止。当左子树为空时则开始访问右子树，由于访问左子节点之后需要反过来访问其右子节点所以此处借用栈的支持。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">preOrderStack</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">TreeNode</span> curr <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/02/hello-world/"/>
      <url>/2021/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
